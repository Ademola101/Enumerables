module Enumerable
  def my_map (&block)
    result = []
    self.each do |element|
    result <<
    block.call(element)
    end
    result
  end

  def my_select(&block)
    result = []
    self.each do |element|
      result << element if block.call(element) == true
    end
    result
  end

  def my_each
    i = 0
    while i < size
      yield self[i]
      i += 1
    end
 end

  def my_any?
    my_each do |item|
      if block_given?
        return true if yield item
      else
        return true if item
      end
    end
    false
  end

  def my_count(arg = nil)
    sum = 0
    if block_given?
      my_each { |a| sum += 1 if yield(a) }
    elsif arg.nil?
      my_each { sum += 1 }
    else
      my_each { sum += 1 if a == arg }
    end
    sum
  end

  def my_none?(arg = nil)
    if block_given?
      my_each { |a| return false if yield(a) }
    elsif arg.nil?
      my_each { |a| return false if a }
    elsif arg.instance_of?(Class)
      my_each { |a| return false if a.class != arg }
    elsif arg.instance_of?(Regexp)
      my_each { |a| return false if a =~ arg }
    else
      my_each { |a| return false if a != arg }
    end
    true
  end
  def my_inject(arg = nil)
    sum = 0
    while sum < length
      if arg.nil?
        sum += 1
        arg = yield(self[0], self[sum])
      else
        arg = yield(arg, self[sum])
      end
      sum += 1
    end
    arg
  end
  def my_inject(arg = nil)
    sum = 0
    while sum < length
      if arg.nil?
        sum += 1
        arg = yield(self[0], self[sum])
      else
        arg = yield(arg, self[sum])
      end
      sum += 1
    end
    arg
  end
end
